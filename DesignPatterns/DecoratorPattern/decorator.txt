Background:
  - Lets say we are building an application for a pizza store
  - Pizza store offers four types of pizza - Peppy Panner, Farm house, Margherita, Chicken Fiesta

Model Diagram:
  - Pizza -> (Name: string, Description: string) -> (getDescription(), getCost())
    - Peppy Panner -> (getCost(): int)
    - Farm house -> (getCost(): int)
    - Margherita -> (getCost(): int)
    - Chicket Fiesta -> (getCost(): int)

- Each pizza has diffrent cost. we have overridden the getCost() in the subclass to find the appropriate cost.
- Now lets say a new requirement in addition to a pizza, customer can also ask for several toppings (Fresh tomato, Panner, Jalapeno etc.,)

Option 1: 
  - create a new subclass for every topping with a pizza. Will exponentially increase the classes and maintainence would be a nightmare.

Option 2:
  - lets add instance variables to pizza base class to represent whether or not each pizza has a topping
  - Sample.,
  public int getCost() {
      int totalToppingCost = 0;
      if (hasJalapeno())
        totalToppingsCost += jalapenoCost;
      if (hasCapsicum() )
        totalToppingsCost += capsicumCost;
      // similarly for other toppings
      return totalToppingsCost;
  }

  // Sample getCost() in subclass
  public int getCost(){
      // 100 for Margherita and super.getCost()
      // for toppings.
      return super.getCost() + 100;
  }

Disadvantages of option2:
  - Price changes in toppings will lead to alteration in the existing code
  - New toppings will force us to add new methods and alter the getCost() method in superclaas.
  - For some pizzas, some toppings may not be appropriate yet the subclass inherits them
  - What if customer wants double capsicum or double cheeseburst?
In short our option2 violates the popular design principle "The-Open-Closed principle" which states that classes should be open for extension and closed for modification

- We use inheritance or composition to extend the behaviour of an object but this is done in compile time and its applicable to all the instances of the classes. we cant add any new functionality or remove any at run time thats when decorator comes into picture
- Decorator pattern is used to modify the functionality of an object at run time. At the same time other instance of the same class will not be affected
- Decorator pattern is one of the structural pattern
- Decorator pattern allows us to add functionality to an object at runtime(not the class)
