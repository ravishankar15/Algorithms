exit
c
n
c
n
c
n
c
exit
c
exit
c
n
cm/10
cv % cm
cv
n
c
n
c
cv
c
cm
cv %cm
res
exit
exti
exit
c
[g1[1] + g2[1]].min
g2[1]
g1[1]
[g1[1] + g2[1]].min
ss
c
g2[1]
g1[1]
ss
n
c
exit
c
nj
ni
n
cr2
n
cp[ni][nj][0].get_rtwo
cr1
n
grid[i][j]
cp[ni][nj][0].get_rone
n
nj
ni
ni, nj
n
nj
ni
ni, nj
n
s
n
c
cr2
cr1
n
exit
c
j
vdays.inspect
i.to_i
days[i][k]
vdays[k-1][j]
n
c
n
s
n
c
n
mod_map
n
mod_res
n
mod_data
mod_res
mod_map
n
mod_res
n
mod_data
mod_res
mod_map
n
mod_data
mod_map
n
exit
exi
n
c
n
mod_res
n
mod_res
n
c
exit
mod_res
n
mod_res
n
exit
exp
c
cval
exp
n
exit
exp
exp.inspect
n
exp[i]
exit
i.to_i
cval
exp[i]
exit
exp
nxt_val
n
c
base**pow
num & (base**pow)
num
mul
n
c
mul
mil
n
comp
n
pow
base
mul
n
comp
n
comp
mul
n
c
op2
op1
val
n
s
opr
opd
n
value
opd
c
val
n
op2
op1
op
n
val
n
op2
op1
op
n
value
c
value
c
curr_cost.inspect
n
c
exit
c
n
exit
c
n
curr_cost
exit
c
curr_cost[j]
n
curr_cost
n
curr_cost
n
prev_cost
curr_cost
c
(i - k)
max_heap.get_max()[1] <= i - k
max_heap.inspect
max_heap.get_max()[1]
n
nums[i]
n
max_heap.get_max()[1]
max_heap.get_max()[1] <= i - k
(i-k).to_i
max_heap.get_max
n
c
n
c
n
c
n
c
mhead
chead
stack.last==chead.next
chead.next
stack.last
c
stack.last == chead.next
chead.next
stack.last
stack.last.next
stack.last.next == chead
c
chead.inspect
stack.last.inspect
stack.last == chead
c
chead
top
n
nxt_chead
n
chead
n
top
chead
n
chead
top
n
nxt_chead
n
chead
c
n
top
